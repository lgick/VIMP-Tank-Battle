![poster](https://github.com/lgick/VIMP-Tank-Battle/blob/master/public/img/poster2.png?raw=true)

# VIMP Tank Battle (в работе)

Многопользовательская 2D онлайн реалтайм игра.

# Установка

```
git clone git@github.com:lgick/VIMP-Tank-Battle.git tank && cd tank && npm i && bower i && node server.js
```

# Параметры при запуске сервера

- `domain` - домен (по умолчанию `localhost`)
- `port` - порт (по умолчанию `3000`)
- `map` - карта при запуске (по умолчанию `arena`)
- `players` - лимит игроков на сервере (по умолчанию `10`)
- `rtime` - время раунда (по умолчанию `60000`)
- `mtime` - время карты (по умолчанию `180000`)
- `friendlyfire` - флаг включения огня по своей команде (по умолчанию: отключен)

Пример запуска:

`node server.js --friendlyfire --players=20 --domain=192.33.44.55 --port=3000 --map=mini --rtime=50000 --mtime=150000`

# WebSocket ports (message-IDs)

## Server: порты получение данных от сервера

| Port |    Name     | Description                                                                                      |
| :--: | :---------: | ------------------------------------------------------------------------------------------------ |
|  0   | config data | Присылает клиентский конфиг                                                                      |
|  1   |  auth data  | После проверки возможности посетить игру присылает данные для авторизации                        |
|  2   | auth errors | После дополнительной проверки данных на сервере присылает ошибки авторизации                     |
|  3   |  map data   | Загрузка данных карты                                                                            |
|  4   |  shot data  | Присылает данные игры, координаты, данные панели, статистики, чата, опроса, данные набора клавиш |
|  5   | inform data | Данные для сообщения "черного экрана"                                                            |
|  6   |    misc     | Присылает разнообразные данные, не имеющие определенного формата                                 |
|  7   |    clear    | Удаляет данные игры                                                                              |
|  8   |   console   | Данные в console.log()                                                                           |

## Client: порты получения данные от клиента

| Port |     Name      | Description                                       |
| :--: | :-----------: | ------------------------------------------------- |
|  0   | config ready  | Пользователь получил данные конфига, canvas готов |
|  1   | auth response | Авторизационные данные пользователя               |
|  2   |   map ready   | Пользователь получил и инициализировал карту      |
|  3   |   keys data   | Данные нажатых клавиш                             |
|  4   |   chat data   | Данные чата/командной строки                      |
|  5   |   vote data   | Данные опроса                                     |

# Модуль PANEL

Данные игры.

Массив с данными `[<время игры>, <данные>, <данные>, <данные>]`.

Первый элемент массива - время игры (секунды).

Если данные - пустая строка `[<время игры>, '', '', '']` - контейнеры этих данных скрываются.
Это нужно для сокрытия лишних данных наблюдателю.

Если данные отстутвуют `[<время игры>]` - контейнеры этих данных игнорируются.

## Конфиг для сервера

```js
panel: {
  health: {
    key: 0,
    value: 100,
  },
  w1: {
    key: 1,
    value: 1000,
  }
}
```

- `key` - порядковый номер в массиве
- `value` - значение по умолчанию (обновляется каждый раунд)

## Конфиг для клиента

```js
panel: {
  elems: {
    time: 'panel-time',
    health: 'panel-health',
    bullet: 'panel-bullet',
    bomb: 'panel-bomb',
  },
  panels: ['time', 'health', 'bullet', 'bomb'],
}
```

- `elems` - id элементов
- `panels` - список названий элементов

# Модуль STAT

Статистика игры.

![stat](https://github.com/lgick/VIMP-Tank-Battle/blob/master/public/img/stat/stat.png?raw=true)

## Конфиг для модели (сервер)

```js
name: {
  key: 0,
  bodyMethod: '=',
  headSync: true,
  headMethod: '#'
},
status: {
  key: 1,
  bodyMethod: '=',
  bodyValue: 'dead',
  headValue: ''
},
score: {
  key: 2,
  bodyMethod: '+',
  bodyValue: 0,
  headMethod: '+',
  headValue: 0
},
deaths: {
  key: 3,
  bodyMethod: '+',
  bodyValue: 0,
  headMethod: '+',
  headValue: 0
}
```

- `key` - порядковый номер в массиве
- `bodyMethod` - метод обновления в body (`=` - замена, `+` - добавление)
- `bodyValue` - значение по умолчанию в body
- `headSync` - синхронизация body с head (`true` или `false`)
- `headMethod` - метод обновления в head (`#` - количество значений, `=` - замена, `+` - добавление)
- `headValue` - значение по умолчанию в head

## Конфиг для модели (клиент)

```js
tables: ['team1', 'team2', 'spectators'],
sortList: {
  'team1': [[2, true], [3, false]],
  'team2': [[2, true], [3, false]]
}
```

- `tables` - массив с id таблиц
- `sortList` - объект с параметрам сортировки

#### Сортировка таблиц

Сортировка осуществляется с учетом объекта `sortList`. Сортировка происходит при добавлении/изменении строки в таблице.

Свойства `sortList` - это id таблиц. Значение свойств - массив с параметрами (например `[[3, true], [4, false]]`).

Массив состоит из подмассивов (например `[3, true]`). Каждый подмассив является параметром для сортировки. Если результат сравнения при сортировки с использованием первого подмассива не даст результата (значения будут эквивалентны), то сортировка будет производится по следующему подмассиву и т.д.

Подмассив состоит из двух значений. Первое - это номер ячейки для сортировки (0 - первая ячейка, 1 - вторая и т.д.), второе значение (булево значение): если `true` - сортировка по убыванию (чем выше строка, тем значение больше), если `false` - сортировка по возрастанию (чем выше строка, тем значение меньше).

## Объект данных с сервера для обновления статистики

```js
statArray = [
  [
    [6, 1, ['bot 6', '', 5, 1], 0],
    [1, 1, ['bot 1', 'dead', 2, 3], 0],
    [4, 1, ['bot 4', '', 0, 4], 0],
    [3, 1, ['bot 3', 'dead', 2, 0], 0],
    [8, 2, ['bot 8', '', 1, 10], 0],
    [23, 2, ['bot 23', '', 1, 8], 0],
    [12, 2, ['bot 12', 'dead', 1, 7], 0],
    [33, 2, null, 0],
    [17, 3, ['bot 17'], 0],
    [64, 3, ['bot 64'], 0],
    [19, 3, null, 0],
  ],
  [
    [1, [3, '', 20, ''], 0],
    [2, [4, '', 30, ''], 0],
  ],
  true,
];
```

### Объект `statArray`

Является массивом и имеет вложенности:

##### `statArray[0]` - данные для `<tbody>`.

Эти данные имеют 4 вложенности:

1. id строки
2. порядковый номер для определения id таблицы
3. массив значений для ячеек
4. номер для tBodies (если несколько `<tbody>`). По умолчанию 0

##### `statArray[1]` - данные для `<thead>`.

Эти данные имеют 3 вложенности:

1. порядковый номер для определения id таблицы
2. массив значений для ячеек
3. номер строки в tHead (если несколько `<tr>`). По умолчанию 0

##### `statArray[2]` - флаг, сообщающий, что обновление полное.

Необязательный параметр, boolean тип

#### Типы значений:

##### Объект `null`

Удаляет строку. Например `['superman', 1, null]` удалит строку, которая имеет атрибут `id='stat_superman'`.

##### Пустая строка

Меняет значение ячейки на пустое. Например `['don', 1, ['don', '', 1, 8]]` - вторая ячейка будет иметь пустое значение.

##### Значение не опеределено (`undefined`)

Не изменяет значение в ячейке. Например `['don', 1, [ , '', , 9]` - первая и третья ячейки останутся без изменений.

# Модуль CHAT

Позволяет игрокам обмениваться текстовыми собщениями и получать системные.

Системные сообщения формируются из шаблонных данных из объекта `messages`

Данные для сообщения могут быть двух видов:

- в виде строки (системное сообщение): `'<группа шаблонов>:<номер шаблона>:<параметры (через запятую)>'`
- в виде массива (сообщение пользователя): `[<текст сообщения>, <имя автора>, <тип для класса>]`

# Модуль VOTE

Позволяет игроку изменять что-то в игре. Например изменить свой статус и перейти в другую команду, или создать голосование для смены карты игры.

Модуль может вызываться без запроса игрока. Пример: другой пользователь захотел сменить карту и создал голосование. У всех пользователей появилось окошко с выбором поддержать или нет это предложение.

### Меню

По умолчанию при вызове модуля отображается меню.

![vote-menu](https://github.com/lgick/VIMP-Tank-Battle/blob/master/public/img/vote/vote-menu.png?raw=true)

```
menu = [
  [
    ['team', false],                     // settings [voteName, timeOff]
    [
      'Сменить команду, статус',         // 0: title
      ['team1', 'team2', 'spectator'],   // 1: value
      null                               // 2: next
    ]
  ],
  [
    ['mapUser', false],
    [
      'Предложить новую карту',
      ['arena', 'arena_2.0', 'mini'],
      null
    ]
  ],
]
```

Голосование может иметь:

- значения подгружаемые с сервера (например список текущих пользователей)
- неограниченное количество уровней опроса
- неограниченное количество возможных значений (появляется навигация в виде `more` и `back`)

### Данные поступающие с сервера могут быть двух видов

- Данные для создания голосования:

```
[
  ['vote name', timeOff],      // [string, boolean || empty]
  [
    'Question',                // 0: string
    ['Value 1', 'Value 2'],    // 1: string[]
    null                       // 2: array || null
  ],
  [gameID, gameID, ...]        // string[] || empty
]
```

- Массив значений на запрос от клиента:

```
[
  null,
  ['user1', 'user2', 'user3', 'user4', 'user5']
]
```

---

Значения в голосовании `values` могут иметь вид:

- `<value>` - value выводится на экран и записывается в data
- `<key>:<value>` - key выводится на экран, value записывается в data

Модуль имеет время жизни `voteTime` и при бездействии пользователя голосование удаляется.
Если в голосовании указан параметр `timeOff: true`, голосование не удаляется.

Результатом голосования будет массив вида `[name, data]`.
`name` - название голосования. `data` - массив значений.

```
['vote name', ['value', 'sub-value', 'sub-sub-value']]
```

# Модуль GAME

### Слои отображения игры на полотне (default layer)

|          Type           | Value |
| :---------------------: | :---: |
| map static data (under) |   1   |
|    map dynamic data     |   2   |
|       game model        |   2   |
|      weapon model       |   2   |
| map static data (over)  |   3   |

# Иерархия элементов (z-index)

| Элемент  | z-index |
| :------: | :-----: |
|   vimp   |    1    |
|  radar   |    2    |
|   chat   |    3    |
|  panel   |    4    |
|   vote   |    5    |
|   stat   |    6    |
|   auth   |    7    |
| informer |    8    |

# GAME CONFIG

## parts

### gameSets

```js
gameSets: {
  c1: ['map', 'mapRadar'],
  c2: ['map'],
  m1: ['tank', 'tankRadar'],
  w1: ['bullet'],
  w2: ['bomb'],
}
```

### entitiesOnCanvas

Объект. В ключе указана сущность, в значении указан холст, в котором отрисована данная сущность.
Предполагается, что сущности можно наследовать, видоизменять и отображать на разных холстах.
Таким образом на радаре можно отобразить не только игроков, но и упрощенную схему карты
(для этого можно создать новую сущность, унаследовать её от сущности map, доработать до требуемого вида)

```js
entitiesOnCanvas: {
  map: 'vimp',
  mapRadar: 'radar',
  tankRadar: 'radar',
  tank: 'vimp',
  bullet: 'vimp',
  bomb: 'vimp',
}
```

## modules

### canvasOptions

Объект данных для масштабирования элемента canvas и кадра игры. Свойства объекта это id элементов canvas. Пример:

```js
canvasOptions: {
  vimp: {
    aspectRatio: '3:2',
    screenRatio: 1,
    scale: '1:1'
  },
  radar: {
    fixSize: '150',
    scale: '1:13'
  }
}
```

#### aspectRatio

Соотношение сторон canvas. Первая цифра - ширина, вторая - высота.

Если указать оба значения равные, например `aspectRatio: '1:1'`, то canvas будет иметь форму квадрата и его высота будет равна ширине.

Если не указывать этот параметр или указать его как `aspectRatio: null`, то ширина и высота будут иметь максимально возможные значения.

#### screenRatio

Коэффициент размера canvas относительно размера окна. Учитывается при ресайзе и означает какую часть свободной области будет использовать canvas.

Например: `screenRatio: 0.5` при ширине свободной области в 1000px образует ширину canvas равной 1000 \* 0.5 = 500px.

Если не указывать этот параметр или указать его как `screenRatio: 1`, размер элемента будет иметь максимально возможные значения.

#### fixSize

Фиксированный размер полотна в `px`. Если указан параметр `fixSize`, параметры `aspectRatio` и `screenRatio` не учитываются.

Если значение одно, оно используется и для ширины и для высоты. Два параметра должны указываться в формате `150:100`,

первое значение - ширина, второе - высота

#### scale

Масштаб изображения на полотне. По умолчанию `scale: '1:1'`.

### keys

Данные о клавишах игры. Пример:

```js
keys: {
  keySetList: [
    // spectator keyset
    {
      // next player (n)
      78: {
        key: 1 << 0,
        type: 1
      },
      // prev player (p)
      80: {
        key: 1 << 1,
        type: 2
      }
    },
    // game keyset
    {
      // forward (w)
      87: {
        key: 1 << 0
      },
      // back (s)
      83: {
        key: 1 << 1
      },
      // left (a)
      65: {
        key: 1 << 2
      },
      // right (d)
      68: {
        key: 1 << 3
      },
      // gCenter (u)
      85: {
        key: 1 << 4
      },
      // gLeft (k)
      75: {
        key: 1 << 5
      },
      // gRight (l)
      76: {
        key: 1 << 6
      },
      // fire (j)
      74: {
        key: 1 << 7,
        type: 1
      }
    }
  ],
  modes: {
    67: 'chat',      // чат (c)
    77: 'vote',      // опрос (m)
    9: 'stat'        // статистика (tab)
  },
  cmds: {
    27: 'escape',    // отмена (escape)
    13: 'enter'      // ввод (enter)
  }
}
```

#### keySetList

Клавиши игры. Массив из 2-х наборов (наблюдатель и играющий).
Клавиша - это объект, где помимо самой клавиши `key`, есть еще параметр `type`, который отвечает за тип обработки клавиши при нажатии.

`type` может иметь значение:

- 0 (по умолчанию): многократное нажатие (начинается на keyDown, завершается на keyUp)
- 1 : выполняется один раз на keyDown
- 2 : выполняется один раз на keyUp

#### modes

Включают различные режимы (чат, опрос, голосование).

#### cmds

Базовые клавиши. Имеют наибольший приоритет и применяются в управлении режимами (чат, голосование и т.д.).

# Данные с сервера

## Данные с сервера для создания кадра игры

Если экземпляр уже создан, данные будут переданы методу **update()** конструктора, и экземпляр просто обновит свои данные.

Если передать `null` - экземпляр будет удален.

### Пример данных для создания кадра игры:

```js
[
  {
    m1: {
      1: [64, 320, 0, 0, 1, 'bob'],
      3: [736, 320, 180, 0, 2, 'jek'],
      5: null,
    },
    w1: [
      [100, 1000, 300, 400],
      [100, 300, 30, 40],
      [10, 100, 30, 0],
    ],
    w2: {
      e3a: [680, 128, -20, 0, 2, 2],
      fsa: [284, 308, 11, 17, 2, 2],
      '4e9': null,
    },
  },
];
```

## Данные с сервера полностью (пример):

```js
[
  // game
  {
    m1: {
      // полные данные об игроке
      // gameID: [x, y, rotation, gunRotation, type, name, width, height],
      3: [736, 320, 180, 0, 2, 'jek', 48, 36],
      5: null,
    },
    w1: {
      e3a: [680, 128, -20, 0, 2, 2],
      fsa: [284, 308, 11, 17, 2, 2],
      '4e9': null,
    },
  },

  // coords [x, y]
  [400, 320],

  // panel
  [97, null, '', 100],

  // stat [tBodies, tHead]
  [
    [
      [6, 1, ['bot 6', '', 5, 1], 0],
      [1, 1, ['bot 1', 'dead', 2, 3], 0],
      [4, 1, ['bot 4', '', 0, 4], 0],
      [3, 1, ['bot 3', 'dead', 2, 0], 0],
      [8, 2, ['bot 8', '', 1, 10], 0],
      [23, 2, ['bot 23', '', 1, 8], 0],
      [12, 2, ['bot 12', 'dead', 1, 7], 0],
      [33, 2, null, 0],
      [17, 3, ['bot 17'], 0],
      [64, 3, ['bot 64'], 0],
      [19, 3, null, 0],
    ],
    [
      [1, [3, '', 20, '']],
      [2, [4, '', 30, '']],
    ],
    true,
  ],

  // chat [text, name, type]
  ['Hello World!', 'User', 1],

  // vote [vote, data]
  [
    ['mapUser'],
    ['Предложить новую карту', ['arena', 'arena_2.0', 'berlin'], null],
  ],

  // keyset (0 - spectator keyset, 1 - game keyset)
  1,
];
```

# Игровой процесс на стороне сервера (`class VIMP`):

1. После проверки возможности посетить игру и прохождения авторизации, в функции `createUser`
   создаётся пользователь. На этом этапе:

- создаётся пользователь и назначаются `gameID`, `name`, `team`, `teamID` и дефолтные настройки
- параметр `isWatching` в значении `true`, `watchedGameID` имеет `gameID` наблюдаемого игрока
  (на данном этапе пользователь наблюдатель)
- статус `user.mapReady` в значении `false`
- добавление пользователя в модули `chat`, `vote`, `stat`, `panel`

2. После загрузки карты и подтверждения от пользователя, что карта готова вызывается функция `mapReady`:

- меняется статус `user.mapReady` в значении `true`
- отправляются полные данные `game`, `stat`, `panel` как у наблюдателя и `vote` с выбором команды

На данном этапе пользователь:

- получает покадровые данные игры из функции `sendShot`,
- наблюдает за игрой, может переключать наблюдаемых игроков.

3. После запуска нового раунда (функция `this.startRound`) начинается игровой процесс:

- удаляются данные активных игроков `this._activePlayersList = []`
- удаляются все игроки и данные пуль из модуля `game`, рассылаются удалённые данные
- заново создаётся карта функцией `this._game.createMap(this._currentMapData)`
- если пользователь сменил команду, происходит смена
- данные `panel` получают дефолтные значения и отправляются
- происходит рассылка полных данных `stat`
- отправка `keySet` - набора клавиш под статус пользователя (см. пункт 4)
- определяются респауны для игроков на карте и создаются игроки

4. Функция `createMap` создаёт карту:

- останавливает все таймеры игры
- сбрасывает данные по количеству игроков в командах (`this._teamSizes`)
- сбрасывает данные модулей `panel`, `stat`, `vote`
- удаляет все данные и создаёт карту в модуле `game`
- отправляет команду о полной очистке полотен пользователям
- переводит всех пользователей в наблюдатели
- отправляет карту пользователям
- запускает таймеры игры

5. Функция `sendShot`:

- обновляет физические данные игры
- формирует список готовых пользователей (у которых `mapReady` === `true`)
- отправляет этим пользователям общие данные модулей `game`, `stat`, `chat`, `vote`
- если для `chat` и `vote` общих данных нет, то, если имеются, отправляются персональные данные
- отправляются данные об удаленных пользователях, координаты наблюдаемых пользователей для наблюдателей, данные `panel`
